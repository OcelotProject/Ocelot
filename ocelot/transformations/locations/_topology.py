# -*- coding: utf-8 -*-
import functools
import json
import os


class Topology(object):
    fp = os.path.join(
        os.path.abspath(os.path.dirname(__file__)),
        "..", "..", "data", "faces.json"
    )

    compatibility = [
        ('IAI Area 1', "IAI Area 1, Africa"),
        ('IAI Area 3', "IAI Area 3, South America"),
        ("IAI Area 4&5 without China", 'IAI Area 4&5, without China'),
        ('IAI Area 8', "IAI Area 8, Gulf"),
        # Compatability for ecoinvent 3.3
        ('IAI Area, North America, without Quebec', 'IAI Area 2, without Quebec'),
        ('IAI Area, South America', 'IAI Area 3, South America'),
        ('IAI Area, Russia & RER w/o EU27 & EFTA', 'IAI Area, Europe outside EU & EFTA'),
        ('IAI Area, Asia, without China and GCC', 'IAI Area 4&5, without China'),
        ('IAI Area, Gulf Cooperation Council', 'IAI Area 8, Gulf'),
        ('IAI Area, Africa', 'IAI Area 1, Africa'),
    ]

    def __init__(self, size_proxy=None):
        self.data = {key: set(value) for key, value in
                     json.load(open(self.fp, encoding='utf-8'))['data']}
        self.data['GLO'] = self.data.pop('__all__')
        self.size_proxy = size_proxy or self.default_size_proxy
        for old, fixed in self.compatibility:
            self.data[old] = self.data[fixed]

    def default_size_proxy(self, face_id):
        """Proxy function to allow for better indicators of area or importance than mere number of faces."""
        return 1

    def resolve_row(self, others):
        """Resolve a ``RoW`` against an iterable of specific regions.

        Implicitly ignores ``RoW`` if present in ``others``."""
        return self("GLO").difference(
            set.union(*[self(place) for place in others])
        )

    def contained(self, location, exclude_self=False, subtract=None,
            resolved_row=None):
        """Return a set of locations which are contained within ``location``.

        If ``resolved_row`` is ``None``, then ``RoW`` contains nothing, **not even itself** (because without ``resolved_row``, we don't know what is included in the "other" ``RoW``).

        ``GLO`` contains ``RoW`` if a) ``RoW`` is resolved, and fits in ``GLO`` (taken ``subtract`` into account); or, b) ``RoW`` is not resolved and there is no ``subtract``.

        Args:

            * ``exclude_self``: Don't return ``location``
            * ``subtract``: Iterable of locations to subtract from ``location`` before doing GIS comparison
            * ``resolved_row``: Set of faces generated by ``topology.resolve_row()``. Used both if ``location`` is ``RoW``, and to determine if ``RoW`` is in ``location``.

        """
        if location == 'RoW' and resolved_row is None:
            return set()
        elif location == 'RoW':
            faces = resolved_row
        elif isinstance(location, set):
            faces = location
        else:
            faces = self(location)

        if subtract:
            faces = faces.difference(set.union(*[self(place) for place in subtract]))

        if not faces:
            # Empty set has no faces - it doesn't include itself because it
            # doesn't exist anywhere in space
            return set()

        result = {key
                  for key, value in self.data.items()
                  if not value.difference(faces)
                  and not (key == location and exclude_self)}
        if (resolved_row not in (set(), None)
            and not resolved_row.difference(faces)
            and not (location == 'RoW' and exclude_self)):
            result.add("RoW")
        # Always include RoW for 'GLO' unless ``resolved_row``
        # (in which case it would already be there if it fit)
        elif location == 'GLO' and resolved_row is None and not subtract:
            result.add("RoW")
        return result

    def contains(self, parent, child, subtract=None, resolved_row=None):
        """Return boolean of whether ``parent`` contains ``child``.

        ``RoW`` handling is a but tricky. We have two possibilities for passing RoW - either the string "RoW", or a set of face ids from ``resolved_row()``. THe problem is that the ``RoW`` in parent is defined independently of ``RoW`` in child. The logic in this function follows the following guidelines:

        * ``contains("RoW", "RoW")``: False. The two RoWs are defined differently, we can't say whether one contains the other.
        * ``contains("RoW", some_set)``: False. Don't know how to define the first ``RoW``.
        * ``contains("RoW", "RoW", resolved_row=some_set)``: False. Don't know how to define the second ``RoW``.
        * resolved_row=another_set)``: True or False, depending on input data.

        Note that the ``resolved_row`` is in the spatial system of ``parent``, not ``child``!

        If ``child`` or ``resolved_row`` is an empty set (either directly, or as a result of ``subtract``), then that location does not exist in space (no face ids at all), and so cannot either contain or be contained by any other spatially resolved location.

        ``GLO`` will contain ``RoW`` (even if ``RoW`` is undefined), as long as ``subtract`` is ``None``.

        """
        if isinstance(child, set):
            # Resolved RoW
            if not child:
                return False
            elif parent == 'RoW':
                faces = resolved_row or set()
            else:
                faces = self(parent)
            if subtract:
                faces = faces.difference(set.union(
                    *[self(place) for place in subtract]
                ))
            return faces.issuperset(child)
        elif parent == "GLO" and child == 'RoW' and not subtract:
            return True
        elif child == 'RoW':
            return False
        else:
            return child in self.contained(
                parent,
                subtract=subtract,
                resolved_row=resolved_row
            )

    def ordered_dependencies(self, datasets, resolved_row=None):
        """Return a list of locations from ``datasets`` in order from largest to smallest.

        Area calculations use ``self.size_proxy``, which by default uses number of topological faces."""
        locations = [ds['location'] for ds in datasets]
        get_faces = lambda loc: resolved_row if (loc == 'RoW' and resolved_row) else self(loc)
        size = lambda loc: sum(self.size_proxy(face)
                               for face in get_faces(loc))

        ordered = sorted(locations, key=lambda k: (size(k), k), reverse=True)
        return ordered

    @functools.lru_cache(maxsize=512)
    def intersected(self, location, exclude_self=False):
        """Not used in Ocelot"""
        if location in ('GLO', 'RoW'):
            return set()
        faces = self(location)
        return {key
                for key, value in self.data.items()
                if value.intersection(faces)
                and not (key == location and exclude_self)}

    def intersects(self, parent, child):
        """Return boolean of whether ``parent`` contains ``child``.

        Not used in Ocelot."""
        return child in self.intersected(parent)

    def overlaps(self, group):
        """Return a boolean if any elements in ``group`` overlap each other."""
        if not group:
            return None
        faces = [self(obj) for obj in group]
        return sum(len(o) for o in faces) != len(set.union(*faces))

    def __call__(self, location):
        if location == 'RoW':
            return set()
        else:
            return self.data[location]
